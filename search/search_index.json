{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the documentation for organize # organize - The file management automation tool Full documentation at Read the docs About Getting started Installation Creating your first rule Example rules Advanced usage Command line interface About # Your desktop is a mess? You cannot find anything in your downloads and documents? Sorting and renaming all these files by hand is too tedious? Time to automate it once and benefit from it forever. organize is a command line, open-source alternative to apps like Hazel (macOS) or File Juggler (Windows). Getting started # Installation # Python 3.6+ is needed. Install it via your package manager or from python.org . Installation is done via pip. Note that the package name is organize-tool : pip3 install -U organize-tool If you want the text extraction capabilities, install with textract like this: pip3 install -U \"organize-tool[textract]\" This command can also be used to update to the newest version. Now you can run organize --help to check if the installation was successful. Creating your first rule # In your shell, run organize config to edit the configuration: rules: - folders: ~/Downloads subfolders: true filters: - extension: pdf actions: - echo: \"Found PDF!\" If you have problems editing the configuration you can run organize config --open-folder to reveal the configuration folder in your file manager. You can then edit the config.yaml in your favourite editor. Alternatively you can run organize config --path to see the full path to your config.yaml ) Save your config file and run organize run . You will see a list of all .pdf files you have in your downloads folder (+ subfolders). For now we only show the text Found PDF! for each file, but this will change soon... (If it shows Nothing to do you simply don't have any pdfs in your downloads folder). Run organize config again and add a copy -action to your rule: actions: - echo: \"Found PDF!\" - move: ~/Documents/PDFs/ Now run organize sim to see what would happen without touching your files . You will see that your pdf-files would be moved over to your Documents/PDFs folder. Congratulations, you just automated your first task. You can now run organize run whenever you like and all your pdfs are a bit more organized. It's that easy. There is so much more. You want to rename / copy files, run custom shell- or python scripts, match filenames with regular expressions or use placeholder variables? organize has you covered. Have a look at the advanced usage example below! Example rules # Here are some examples of simple organization and cleanup rules. Modify to your needs! Move all invoices, orders or purchase documents into your documents folder: rules: # sort my invoices and receipts - folders: ~/Downloads subfolders: true filters: - extension: pdf - filename: contains: - Invoice - Order - Purchase case_sensitive: false actions: - move: ~/Documents/Shopping/ Move incomplete downloads older than 30 days into the trash: rules: # move incomplete downloads older > 30 days into the trash - folders: ~/Downloads filters: - extension: - download - crdownload - part - lastmodified: days: 30 mode: older actions: - trash Delete empty files from downloads and desktop: rules: # delete empty files from downloads and desktop - folders: - ~/Downloads - ~/Desktop filters: - filesize: 0 actions: - trash Move screenshots into a \"Screenshots\" folder on your desktop: rules: # move screenshots into \"Screenshots\" folder - folders: ~/Desktop filters: - filename: startswith: \"Screen Shot\" actions: - move: ~/Desktop/Screenshots/ Organize your font downloads: rules: # organize your font files but keep the folder structure: # \"~/Downloads/favourites/helvetica/helvetica-bold.ttf\" # is moved to # \"~/Documents/FONTS/favourites/helvetica/helvetica-bold.ttf\" - folders: ~/Downloads/**/*.ttf actions: - Move: \"~/Documents/FONTS/{relative_path}\" You'll find many more examples in the full documentation . Advanced usage # This example shows some advanced features like placeholder variables, pluggable actions, recursion through subfolders and glob syntax: rules: - folders: ~/Documents/**/* filters: - extension: - pdf - docx - created actions: - move: \"~/Documents/{extension.upper}/{created.year}{created.month:02}/\" - shell: 'open \"{path}\"' Given we have two files in our ~/Documents folder (or any of its subfolders) named script.docx from january 2018 and demo.pdf from december 2016 this will happen: script.docx will be moved to ~/Documents/DOCX/2018-01/script.docx demo.pdf will be moved to ~/Documents/PDF/2016-12/demo.pdf The files will be opened ( open command in macOS) from their new location . Note the format syntax for {created.month} to make sure the month is prepended with a zero. Command line interface # The file management automation tool. Usage: organize sim [--config-file=<path>] organize run [--config-file=<path>] organize config [--open-folder | --path | --debug] [--config-file=<path>] organize list organize --help organize --version Arguments: sim Simulate a run. Does not touch your files. run Organizes your files according to your rules. config Open the configuration file in $EDITOR. list List available filters and actions. --version Show program version and exit. -h, --help Show this screen and exit. Options: -o, --open-folder Open the folder containing the configuration files. -p, --path Show the path to the configuration file. -d, --debug Debug your configuration file. Full documentation: https://organize.readthedocs.io","title":"Home"},{"location":"#welcome-to-the-documentation-for-organize","text":"organize - The file management automation tool Full documentation at Read the docs About Getting started Installation Creating your first rule Example rules Advanced usage Command line interface","title":"Welcome to the documentation for organize"},{"location":"#about","text":"Your desktop is a mess? You cannot find anything in your downloads and documents? Sorting and renaming all these files by hand is too tedious? Time to automate it once and benefit from it forever. organize is a command line, open-source alternative to apps like Hazel (macOS) or File Juggler (Windows).","title":"About"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#installation","text":"Python 3.6+ is needed. Install it via your package manager or from python.org . Installation is done via pip. Note that the package name is organize-tool : pip3 install -U organize-tool If you want the text extraction capabilities, install with textract like this: pip3 install -U \"organize-tool[textract]\" This command can also be used to update to the newest version. Now you can run organize --help to check if the installation was successful.","title":"Installation"},{"location":"#creating-your-first-rule","text":"In your shell, run organize config to edit the configuration: rules: - folders: ~/Downloads subfolders: true filters: - extension: pdf actions: - echo: \"Found PDF!\" If you have problems editing the configuration you can run organize config --open-folder to reveal the configuration folder in your file manager. You can then edit the config.yaml in your favourite editor. Alternatively you can run organize config --path to see the full path to your config.yaml ) Save your config file and run organize run . You will see a list of all .pdf files you have in your downloads folder (+ subfolders). For now we only show the text Found PDF! for each file, but this will change soon... (If it shows Nothing to do you simply don't have any pdfs in your downloads folder). Run organize config again and add a copy -action to your rule: actions: - echo: \"Found PDF!\" - move: ~/Documents/PDFs/ Now run organize sim to see what would happen without touching your files . You will see that your pdf-files would be moved over to your Documents/PDFs folder. Congratulations, you just automated your first task. You can now run organize run whenever you like and all your pdfs are a bit more organized. It's that easy. There is so much more. You want to rename / copy files, run custom shell- or python scripts, match filenames with regular expressions or use placeholder variables? organize has you covered. Have a look at the advanced usage example below!","title":"Creating your first rule"},{"location":"#example-rules","text":"Here are some examples of simple organization and cleanup rules. Modify to your needs! Move all invoices, orders or purchase documents into your documents folder: rules: # sort my invoices and receipts - folders: ~/Downloads subfolders: true filters: - extension: pdf - filename: contains: - Invoice - Order - Purchase case_sensitive: false actions: - move: ~/Documents/Shopping/ Move incomplete downloads older than 30 days into the trash: rules: # move incomplete downloads older > 30 days into the trash - folders: ~/Downloads filters: - extension: - download - crdownload - part - lastmodified: days: 30 mode: older actions: - trash Delete empty files from downloads and desktop: rules: # delete empty files from downloads and desktop - folders: - ~/Downloads - ~/Desktop filters: - filesize: 0 actions: - trash Move screenshots into a \"Screenshots\" folder on your desktop: rules: # move screenshots into \"Screenshots\" folder - folders: ~/Desktop filters: - filename: startswith: \"Screen Shot\" actions: - move: ~/Desktop/Screenshots/ Organize your font downloads: rules: # organize your font files but keep the folder structure: # \"~/Downloads/favourites/helvetica/helvetica-bold.ttf\" # is moved to # \"~/Documents/FONTS/favourites/helvetica/helvetica-bold.ttf\" - folders: ~/Downloads/**/*.ttf actions: - Move: \"~/Documents/FONTS/{relative_path}\" You'll find many more examples in the full documentation .","title":"Example rules"},{"location":"#advanced-usage","text":"This example shows some advanced features like placeholder variables, pluggable actions, recursion through subfolders and glob syntax: rules: - folders: ~/Documents/**/* filters: - extension: - pdf - docx - created actions: - move: \"~/Documents/{extension.upper}/{created.year}{created.month:02}/\" - shell: 'open \"{path}\"' Given we have two files in our ~/Documents folder (or any of its subfolders) named script.docx from january 2018 and demo.pdf from december 2016 this will happen: script.docx will be moved to ~/Documents/DOCX/2018-01/script.docx demo.pdf will be moved to ~/Documents/PDF/2016-12/demo.pdf The files will be opened ( open command in macOS) from their new location . Note the format syntax for {created.month} to make sure the month is prepended with a zero.","title":"Advanced usage"},{"location":"#command-line-interface","text":"The file management automation tool. Usage: organize sim [--config-file=<path>] organize run [--config-file=<path>] organize config [--open-folder | --path | --debug] [--config-file=<path>] organize list organize --help organize --version Arguments: sim Simulate a run. Does not touch your files. run Organizes your files according to your rules. config Open the configuration file in $EDITOR. list List available filters and actions. --version Show program version and exit. -h, --help Show this screen and exit. Options: -o, --open-folder Open the folder containing the configuration files. -p, --path Show the path to the configuration file. -d, --debug Debug your configuration file. Full documentation: https://organize.readthedocs.io","title":"Command line interface"},{"location":"01-config/","text":"Configuration # Editing the configuration # All configuration takes place in your config.yaml file. To edit your configuration in $EDITOR run: $ organize config # example: \"EDITOR=vim organize config\" To show the full path to your configuration file: $ organize config --path To open the folder containing the configuration file: $ organize config --open-folder To debug your configuration run: $ organize config --debug Environment variables # $EDITOR - The editor used to edit the config file. $ORGANIZE_CONFIG - The config file path. Is overridden by --config-file cmd line argument. Rule syntax # The rule configuration is done in YAML . You need a top-level element rules which contains a list of rules. Each rule defines folders , filters (optional) and actions . rules: - folders: - ~/Desktop - /some/folder/ filters: - lastmodified: days: 40 mode: newer - extension: pdf actions: - move: ~/Desktop/Target/ - trash - folders: - ~/Inbox filters: - extension: pdf actions: - move: ~/otherinbox folders is a list of folders you want to organize. filters is a list of filters to apply to the files - you can filter by file extension, last modified date, regular expressions and many more. See :ref: Filters . actions is a list of actions to apply to the filtered files. You can put them into the trash, move them into another folder and many more. See :ref: Actions . Other optional per rule settings: enabled can be used to temporarily disable single rules. Default = true subfolders specifies whether subfolders should be included in the search. Default = false. This setting only applies to folders without glob wildcards. system_files specifies whether to include system files (desktop.ini, thumbs.db, .DS_Store) in the search. Default = false Folder syntax # Every rule in your configuration file needs to know the folders it applies to. The easiest way is to define the rules like this: .. code-block:: yaml :caption: config.yaml rules: - folders: - /path/one - /path/two filters: ... actions: ... - folders: - /path/one - /another/path filters: ... actions: ... .. note:: You can use environment variables in your folder names. On windows this means you can use %public%/Desktop , %APPDATA% , %PROGRAMDATA% etc. Globstrings # You can use globstrings in the folder lists. For example to get all files with filenames ending with _ui and any file extension you can use: .. code-block:: yaml :caption: config.yaml rules: - folders: - '~/Downloads/ _ui. ' actions: - echo: '{path}' You can use globstrings to recurse through subdirectories (alternatively you can use the subfolders: true setting as shown below) .. code-block:: yaml :caption: config.yaml rules: - folders: - '~/Downloads/* / .*' actions: - echo: 'base {basedir}, path {path}, relative: {relative_path}' # alternative syntax - folders: - ~/Downloads subfolders: true actions: - echo: 'base {basedir}, path {path}, relative: {relative_path}' The following example recurses through all subdirectories in your downloads folder and finds files with ending in .c and .h . .. code-block:: yaml :caption: config.yaml rules: - folders: - '~/Downloads/* / .[c|h]' actions: - echo: '{path}' .. note:: You have to target files with the globstring, not folders. So to scan through all folders starting with _log__ you would write yourpath/log\\_\\_/_ Excluding files and folders # Files and folders can be excluded by prepending an exclamation mark. The following example selects all files in ~/Downloads and its subfolders - excluding the folder Software : .. code-block:: yaml :caption: config.yaml rules: - folders: - '~/Downloads/* / ' - '! ~/Downloads/Software' actions: - echo: '{path}' Globstrings can be used to exclude only specific files / folders. This example: adds all files in ~/Downloads exludes files from that list whose name contains the word system ending in .bak adds all files from ~/Documents excludes the file ~/Documents/important.txt . .. code-block:: yaml :caption: config.yaml rules: - folders: - '~/Downloads/ /*' - '! ~/Downloads/ / system .bak' - '~/Documents' - '! ~/Documents/important.txt' actions: - echo: '{path}' .. note:: Files and folders are included and excluded in the order you specify them! Please make sure your are putting the exclamation mark within quotation marks. Aliases # Instead of repeating the same folders in each and every rule you can use an alias for multiple folders which you can then reference in each rule. Aliases are a standard feature of the YAML syntax. .. code-block:: yaml :caption: config.yaml all_my_messy_folders: &all - ~/Desktop - ~/Downloads - ~/Documents - ~/Dropbox rules: - folders: *all filters: ... actions: ... - folders: *all filters: ... actions: ... You can even use multiple folder lists: .. code-block:: yaml :caption: config.yaml private_folders: &private - '/path/private' - '~/path/private' work_folders: &work - '/path/work' - '~/My work folder' all_folders: &all - private - work rules: - folders: *private filters: ... actions: ... - folders: *work filters: ... actions: ... - folders: *all filters: ... actions: ... # same as *all - folders: - *work - *private filters: ... actions: ... Filter syntax # filters is a list of :ref: Filters . Filters are defined like this: .. code-block:: yaml :caption: config.yaml rules: - folders: ... actions: ... filters: # filter without parameters - FilterName # filter with a single parameter - FilterName: parameter # filter expecting a list as parameter - FilterName: - first - second - third # filter with multiple parameters - FilterName: parameter1: true option2: 10.51 third_argument: test string .. note:: Every filter comes with multiple usage examples which should be easy to adapt for your use case! Action syntax # actions is a list of :ref: Actions . Actions can be defined like this: .. code-block:: yaml :caption: config.yaml rules: - folders: ... actions: # action without parameters - ActionName # action with a single parameter - ActionName: parameter # filter with multiple parameters - ActionName: parameter1: true option2: 10.51 third_argument: test string .. note:: Every action comes with multiple usage examples which should be easy to adapt for your use case! Variable substitution (placeholders) # You can use placeholder variables in your actions. Placeholder variables are used with curly braces {var} . You always have access to the variables {path} , {basedir} and {relative_path} : {path} -- is the full path to the current file {basedir} -- the current base folder (the base folder is the folder you specify in your configuration). {relative_path} -- the relative path from {basedir} to {path} Use the dot notation to access properties of {path} , {basedir} and {relative_path} : {path} -- the full path to the current file {path.name} -- the full filename including extension {path.stem} -- just the file name without extension {path.suffix} -- the file extension {path.parent} -- the parent folder of the current file {path.parent.parent} -- parent calls are chainable... {basedir} -- the full path to the current base folder {basedir.parent} -- the full path to the base folder's parent and any other property of the python pathlib.Path ( official documentation <https://docs.python.org/3/library/pathlib.html#methods-and-properties> _) object. Additionally :ref: Filters may emit placeholder variables when applied to a path. Check the documentation and examples of the filter to see available placeholder variables and usage examples. Some examples include: {lastmodified.year} -- the year the file was last modified {regex.yournamedgroup} -- anything you can extract via regular expressions {extension.upper} -- the file extension in uppercase ... and many more.","title":"Configuration"},{"location":"01-config/#configuration","text":"","title":"Configuration"},{"location":"01-config/#editing-the-configuration","text":"All configuration takes place in your config.yaml file. To edit your configuration in $EDITOR run: $ organize config # example: \"EDITOR=vim organize config\" To show the full path to your configuration file: $ organize config --path To open the folder containing the configuration file: $ organize config --open-folder To debug your configuration run: $ organize config --debug","title":"Editing the configuration"},{"location":"01-config/#environment-variables","text":"$EDITOR - The editor used to edit the config file. $ORGANIZE_CONFIG - The config file path. Is overridden by --config-file cmd line argument.","title":"Environment variables"},{"location":"01-config/#rule-syntax","text":"The rule configuration is done in YAML . You need a top-level element rules which contains a list of rules. Each rule defines folders , filters (optional) and actions . rules: - folders: - ~/Desktop - /some/folder/ filters: - lastmodified: days: 40 mode: newer - extension: pdf actions: - move: ~/Desktop/Target/ - trash - folders: - ~/Inbox filters: - extension: pdf actions: - move: ~/otherinbox folders is a list of folders you want to organize. filters is a list of filters to apply to the files - you can filter by file extension, last modified date, regular expressions and many more. See :ref: Filters . actions is a list of actions to apply to the filtered files. You can put them into the trash, move them into another folder and many more. See :ref: Actions . Other optional per rule settings: enabled can be used to temporarily disable single rules. Default = true subfolders specifies whether subfolders should be included in the search. Default = false. This setting only applies to folders without glob wildcards. system_files specifies whether to include system files (desktop.ini, thumbs.db, .DS_Store) in the search. Default = false","title":"Rule syntax"},{"location":"01-config/#folder-syntax","text":"Every rule in your configuration file needs to know the folders it applies to. The easiest way is to define the rules like this: .. code-block:: yaml :caption: config.yaml rules: - folders: - /path/one - /path/two filters: ... actions: ... - folders: - /path/one - /another/path filters: ... actions: ... .. note:: You can use environment variables in your folder names. On windows this means you can use %public%/Desktop , %APPDATA% , %PROGRAMDATA% etc.","title":"Folder syntax"},{"location":"01-config/#globstrings","text":"You can use globstrings in the folder lists. For example to get all files with filenames ending with _ui and any file extension you can use: .. code-block:: yaml :caption: config.yaml rules: - folders: - '~/Downloads/ _ui. ' actions: - echo: '{path}' You can use globstrings to recurse through subdirectories (alternatively you can use the subfolders: true setting as shown below) .. code-block:: yaml :caption: config.yaml rules: - folders: - '~/Downloads/* / .*' actions: - echo: 'base {basedir}, path {path}, relative: {relative_path}' # alternative syntax - folders: - ~/Downloads subfolders: true actions: - echo: 'base {basedir}, path {path}, relative: {relative_path}' The following example recurses through all subdirectories in your downloads folder and finds files with ending in .c and .h . .. code-block:: yaml :caption: config.yaml rules: - folders: - '~/Downloads/* / .[c|h]' actions: - echo: '{path}' .. note:: You have to target files with the globstring, not folders. So to scan through all folders starting with _log__ you would write yourpath/log\\_\\_/_","title":"Globstrings"},{"location":"01-config/#excluding-files-and-folders","text":"Files and folders can be excluded by prepending an exclamation mark. The following example selects all files in ~/Downloads and its subfolders - excluding the folder Software : .. code-block:: yaml :caption: config.yaml rules: - folders: - '~/Downloads/* / ' - '! ~/Downloads/Software' actions: - echo: '{path}' Globstrings can be used to exclude only specific files / folders. This example: adds all files in ~/Downloads exludes files from that list whose name contains the word system ending in .bak adds all files from ~/Documents excludes the file ~/Documents/important.txt . .. code-block:: yaml :caption: config.yaml rules: - folders: - '~/Downloads/ /*' - '! ~/Downloads/ / system .bak' - '~/Documents' - '! ~/Documents/important.txt' actions: - echo: '{path}' .. note:: Files and folders are included and excluded in the order you specify them! Please make sure your are putting the exclamation mark within quotation marks.","title":"Excluding files and folders"},{"location":"01-config/#aliases","text":"Instead of repeating the same folders in each and every rule you can use an alias for multiple folders which you can then reference in each rule. Aliases are a standard feature of the YAML syntax. .. code-block:: yaml :caption: config.yaml all_my_messy_folders: &all - ~/Desktop - ~/Downloads - ~/Documents - ~/Dropbox rules: - folders: *all filters: ... actions: ... - folders: *all filters: ... actions: ... You can even use multiple folder lists: .. code-block:: yaml :caption: config.yaml private_folders: &private - '/path/private' - '~/path/private' work_folders: &work - '/path/work' - '~/My work folder' all_folders: &all - private - work rules: - folders: *private filters: ... actions: ... - folders: *work filters: ... actions: ... - folders: *all filters: ... actions: ... # same as *all - folders: - *work - *private filters: ... actions: ...","title":"Aliases"},{"location":"01-config/#filter-syntax","text":"filters is a list of :ref: Filters . Filters are defined like this: .. code-block:: yaml :caption: config.yaml rules: - folders: ... actions: ... filters: # filter without parameters - FilterName # filter with a single parameter - FilterName: parameter # filter expecting a list as parameter - FilterName: - first - second - third # filter with multiple parameters - FilterName: parameter1: true option2: 10.51 third_argument: test string .. note:: Every filter comes with multiple usage examples which should be easy to adapt for your use case!","title":"Filter syntax"},{"location":"01-config/#action-syntax","text":"actions is a list of :ref: Actions . Actions can be defined like this: .. code-block:: yaml :caption: config.yaml rules: - folders: ... actions: # action without parameters - ActionName # action with a single parameter - ActionName: parameter # filter with multiple parameters - ActionName: parameter1: true option2: 10.51 third_argument: test string .. note:: Every action comes with multiple usage examples which should be easy to adapt for your use case!","title":"Action syntax"},{"location":"01-config/#variable-substitution-placeholders","text":"You can use placeholder variables in your actions. Placeholder variables are used with curly braces {var} . You always have access to the variables {path} , {basedir} and {relative_path} : {path} -- is the full path to the current file {basedir} -- the current base folder (the base folder is the folder you specify in your configuration). {relative_path} -- the relative path from {basedir} to {path} Use the dot notation to access properties of {path} , {basedir} and {relative_path} : {path} -- the full path to the current file {path.name} -- the full filename including extension {path.stem} -- just the file name without extension {path.suffix} -- the file extension {path.parent} -- the parent folder of the current file {path.parent.parent} -- parent calls are chainable... {basedir} -- the full path to the current base folder {basedir.parent} -- the full path to the base folder's parent and any other property of the python pathlib.Path ( official documentation <https://docs.python.org/3/library/pathlib.html#methods-and-properties> _) object. Additionally :ref: Filters may emit placeholder variables when applied to a path. Check the documentation and examples of the filter to see available placeholder variables and usage examples. Some examples include: {lastmodified.year} -- the year the file was last modified {regex.yournamedgroup} -- anything you can extract via regular expressions {extension.upper} -- the file extension in uppercase ... and many more.","title":"Variable substitution (placeholders)"},{"location":"02-locations/","text":"Locations #","title":"Locations"},{"location":"02-locations/#locations","text":"","title":"Locations"},{"location":"03-filters/","text":"Filters # This page shows the specifics of each filter. For basic filter usage and options have a look at the Config section. created # Matches files / folders by created date Parameters: years ( int ) \u2013 specify number of years months ( int ) \u2013 specify number of months weeks ( float ) \u2013 specify number of weeks days ( float ) \u2013 specify number of days hours ( float ) \u2013 specify number of hours minutes ( float ) \u2013 specify number of minutes seconds ( float ) \u2013 specify number of seconds mode ( str ) \u2013 either 'older' or 'newer'. 'older' matches all files created before the given time, 'newer' matches all files created within the given time. (default = 'older') Returns: {created} \u2013 The datetime the file / dir was created. Examples - : rules: - name: Show all files on your desktop created at least 10 days ago locations: \"~/Desktop\" filters: - created: days: 10 actions: - echo: \"Was created at least 10 days ago\" rules: - name: Show all files on your desktop which were created within the last 5 hours locations: \"~/Desktop\" filters: - created: hours: 5 mode: newer actions: - echo: \"Was created within the last 5 hours\" rules: - name: Sort pdfs by year of creation locations: \"~/Documents\" filters: - extension: pdf - created actions: - move: \"~/Documents/PDF/{created.year}/\" duplicate # Finds duplicate files. This filter compares files byte by byte and finds identical files with potentially different filenames. :returns: - {duplicate} -- path to the duplicate source rules: - name: Show all duplicate files in your desktop and download folder (and their subfolders) locations: - ~/Desktop - ~/Downloads sublocations: true filters: - duplicate actions: - echo: \"{path} is a duplicate of {duplicate}\" empty # Finds empty dirs and files rules: - name: \"Recursively delete empty folders\" targets: dirs locations: - path: ~/Desktop max_depth: null filters: - empty actions: - delete exif # Filter by image EXIF data The exif filter can be used as a filter as well as a way to get exif information into your actions. :returns: {exif} -- a dict of all the collected exif inforamtion available in the file. Typically it consists of the following tags (if present in the file): - ``{exif.image}`` -- information related to the main image - ``{exif.exif}`` -- Exif information - ``{exif.gps}`` -- GPS information - ``{exif.interoperability}`` -- Interoperability information Examples: Show available EXIF data of your pictures: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Pictures subfolders: true filters: - exif actions: - echo: \"{exif}\" Copy all images which contain GPS information while keeping subfolder structure: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Pictures subfolders: true filters: - exif: gps.gpsdate actions: - copy: ~/Pictures/with_gps/{relative_path}/ Filter by camera manufacturer: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Pictures subfolders: true filters: - exif: image.model: Nikon D3200 actions: - move: '~/Pictures/My old Nikon/' Sort images by camera manufacturer. This will create folders for each camera model (for example \"Nikon D3200\", \"iPhone 6s\", \"iPhone 5s\", \"DMC-GX80\") and move the pictures accordingly: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Pictures subfolders: true filters: - extension: jpg - exif: image.model actions: - move: '~/Pictures/{exif.image.model}/' extension # Filter by file extension :param extensions: The file extensions to match (does not need to start with a colon). :returns: - {extension} -- the original file extension (without colon) - {extension.lower} -- the file extension in lowercase - {extension.upper} -- the file extension in UPPERCASE Examples: Match a single file extension: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - extension: png actions: - echo: 'Found PNG file: {path}' Match multiple file extensions: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - extension: - .jpg - jpeg actions: - echo: 'Found JPG file: {path}' Make all file extensions lowercase: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - extension actions: - rename: '{path.stem}.{extension.lower}' Using extension lists: .. code-block:: yaml :caption: config.yaml img_ext: &img - png - jpg - tiff audio_ext: &audio - mp3 - wav - ogg rules: - folders: '~/Desktop' filters: - extension: - *img - *audio actions: - echo: 'Found media file: {path}' filecontent # Matches file content with the given regular expression :param str expr: The regular expression to be matched. Any named groups in your regular expression will be returned like this: :returns: - {filecontent.yourgroupname} -- The text matched with the named group (?P<yourgroupname>) Examples: Show the content of all your PDF files: .. code-block::yaml :caption: config.yaml rules: - folders: ~/Documents filters: - extension: pdf - filecontent: '(?P<all>.*)' actions: - echo: \"{filecontent.all}\" Match an invoice with a regular expression and sort by customer: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - filecontent: 'Invoice.*Customer (?P<customer>\\w+)' actions: - move: '~/Documents/Invoices/{filecontent.customer}/' hash # Calculates the hash of a file. Parameters: algorithm ( str ) \u2013 Any hashing algorithm available to python's hashlib . md5 by default. Algorithms guaranteed to be available are shake_256 , sha3_256 , sha1 , sha3_224 , sha384 , sha512 , blake2b , blake2s , sha256 , sha224 , shake_128 , sha3_512 , sha3_384 and md5 . Depending on your python installation and installed libs there may be additional hash algorithms to chose from. To list the available algorithms on your installation run this in a python interpreter: >>> import hashlib >>> hashlib.algorithms_available {'shake_256', 'whirlpool', 'mdc2', 'blake2s', 'sha224', 'shake_128', 'sha3_512', 'sha3_224', 'sha384', 'md5', 'sha1', 'sha512_256', 'blake2b', 'sha256', 'sha512_224', 'ripemd160', 'sha3_384', 'md4', 'sm3', 'sha3_256', 'md5-sha1', 'sha512'} Returns: str \u2013 The hash of the file. name # Match files by filename :param str match: A matching string in simplematch -syntax (https://github.com/tfeldmann/simplematch) :param str startswith: The filename must begin with the given string :param str contains: The filename must contain the given string :param str endswith: The filename (without extension) must end with the given string :param bool case_sensitive = True: By default, the matching is case sensitive. Change this to False to use case insensitive matching. Examples: Match all files starting with 'Invoice': .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - filename: startswith: Invoice actions: - echo: 'This is an invoice' Match all files starting with 'A' end containing the string 'hole' (case insensitive) .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - filename: startswith: A contains: hole case_sensitive: false actions: - echo: 'Found a match.' Match all files starting with 'A' or 'B' containing '5' or '6' and ending with '_end' .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - filename: startswith: - A - B contains: - 5 - 6 endswith: _end case_sensitive: false actions: - echo: 'Found a match.' size # Matches files and folders by size :param str conditions: Accepts file size conditions, e.g: '>= 500 MB' , '< 20k' , '>0' , '= 10 KiB' . It is possible to define both lower and upper conditions like this: '>20k, < 1 TB' , '>= 20 Mb, <25 Mb' . The filter will match if all given conditions are satisfied. Accepts all units from KB to YB. If no unit is given, kilobytes are assumend. If binary prefix is given (KiB, GiB) the size is calculated using base 1024. :returns: - {size.bytes} -- Size in bytes Examples: Trash big downloads: .. code-block:: yaml :caption: config.yaml rules: - locations: '~/Downloads' targets: files filters: - filesize: '> 0.5 GB' actions: - trash Move all JPEGS bigger > 1MB and <10 MB. Search all subfolders and keep the original relative path. .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Pictures' subfolders: true filters: - extension: - jpg - jpeg - filesize: '>1mb, <10mb' actions: - move: '~/Pictures/sorted/{relative_path}/' lastmodified # Matches files by last modified date :param int years: specify number of years :param int months: specify number of months :param float weeks: specify number of weeks :param float days: specify number of days :param float hours: specify number of hours :param float minutes: specify number of minutes :param float seconds: specify number of seconds :param str mode: either 'older' or 'newer'. 'older' matches all files last modified before the given time, 'newer' matches all files last modified within the given time. (default = 'older') :returns: - {lastmodified.year} -- the year the file was last modified - {lastmodified.month} -- the month the file was last modified - {lastmodified.day} -- the day the file was last modified - {lastmodified.hour} -- the hour the file was last modified - {lastmodified.minute} -- the minute the file was last modified - {lastmodified.second} -- the second the file was last modified Examples: Show all files on your desktop last modified at least 10 days ago: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - lastmodified: days: 10 actions: - echo: 'Was modified at least 10 days ago' Show all files on your desktop which were modified within the last 5 hours: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - lastmodified: hours: 5 mode: newer actions: - echo: 'Was modified within the last 5 hours' Sort pdfs by year of last modification .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Documents' filters: - extension: pdf - lastmodified actions: - move: '~/Documents/PDF/{lastmodified.year}/' mimetype # Filter by MIME type associated with the file extension. Supports a single string or list of MIME type strings as argument. The types don't need to be fully specified, for example \"audio\" matches everything from \"audio/midi\" to \"audio/quicktime\". You can see a list of known MIME types on your system by running this oneliner: .. code-block:: yaml python3 -c \"import mimetypes as m; print('\\n'.join(sorted(set(m.common_types.values()) | set(m.types_map.values()))))\" Examples rules: - name: \"Show MIME types\" locations: \"~/Downloads\" filters: - mimetype actions: - echo: \"{mimetype}\" rules: - name: \"Filter by 'image' mimetype\" locations: \"~/Downloads\" filters: - mimetype: image actions: - echo: \"This file is an image: {mimetype}\" rules: - name: Filter by specific MIME type locations: \"~/Desktop\" filters: - mimetype: application/pdf actions: - echo: \"Found a PDF file\" rules: - name: Filter by multiple specific MIME types locations: \"~/Music\" filters: - mimetype: - application/pdf - audio/midi actions: - echo: \"Found Midi or PDF.\" python # Use python code to filter files. :param str code: The python code to execute. The code must contain a return statement. :returns: - If your code returns False or None the file is filtered out, otherwise the file is passed on to the next filters. - {python} contains the returned value. If you return a dictionary (for example return {\"some_key\": some_value, \"nested\": {\"k\": 2}} ) it will be accessible via dot syntax in your actions: {python.some_key} , {python.nested.k} . Examples rules: - name: A file name reverser. locations: ~/Documents filters: - extension - python: | return {\"reversed_name\": path.stem[::-1]} actions: - rename: \"{python.reversed_name}.{extension}\" A filter for odd student numbers. Assuming the folder ~/Students contains the files student-01.jpg , student-01.txt , student-02.txt and student-03.txt this rule will print \"Odd student numbers: student-01.txt\" and \"Odd student numbers: student-03.txt\" rules: - name: \"Filter odd student numbers\" locations: ~/Students/ filters: - python: | return int(path.stem.split('-')[1]) % 2 == 1 actions: - echo: \"Odd student numbers: {path.name}\" Advanced usecase. You can access data from previous filters in your python code. This can be used to match files and capturing names with a regular expression and then renaming the files with the output of your python script. rules: - name: \"Access placeholders in python filter\" locations: files filters: - extension: txt - regex: (?P<firstname>\\w+)-(?P<lastname>\\w+)\\..* - python: | emails = { \"Betts\": \"dbetts@mail.de\", \"Cornish\": \"acornish@google.com\", \"Bean\": \"dbean@aol.com\", \"Frey\": \"l-frey@frey.org\", } if regex.lastname in emails: # get emails from wherever return {\"mail\": emails[regex.lastname]} actions: - rename: \"{python.mail}.txt\" Result: Devonte-Betts.txt becomes dbetts@mail.de.txt Alaina-Cornish.txt becomes acornish@google.com.txt Dimitri-Bean.txt becomes dbean@aol.com.txt Lowri-Frey.txt becomes l-frey@frey.org.txt Someunknown-User.txt remains unchanged because the email is not found regex # Matches filenames with the given regular expression :param str expr: The regular expression to be matched. Any named groups in your regular expression will be returned like this: :returns: - {regex.yourgroupname} -- The text matched with the named group (?P<yourgroupname>) Examples: Match an invoice with a regular expression: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - regex: '^RG(\\d{12})-sig\\.pdf$' actions: - move: '~/Documents/Invoices/1und1/' Match and extract data from filenames with regex named groups: This is just like the previous example but we rename the invoice using the invoice number extracted via the regular expression and the named group the_number . .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop filters: - regex: '^RG(?P<the_number>\\d{12})-sig\\.pdf$' actions: - move: ~/Documents/Invoices/1und1/{regex.the_number}.pdf","title":"Filters"},{"location":"03-filters/#filters","text":"This page shows the specifics of each filter. For basic filter usage and options have a look at the Config section.","title":"Filters"},{"location":"03-filters/#created","text":"Matches files / folders by created date Parameters: years ( int ) \u2013 specify number of years months ( int ) \u2013 specify number of months weeks ( float ) \u2013 specify number of weeks days ( float ) \u2013 specify number of days hours ( float ) \u2013 specify number of hours minutes ( float ) \u2013 specify number of minutes seconds ( float ) \u2013 specify number of seconds mode ( str ) \u2013 either 'older' or 'newer'. 'older' matches all files created before the given time, 'newer' matches all files created within the given time. (default = 'older') Returns: {created} \u2013 The datetime the file / dir was created. Examples - : rules: - name: Show all files on your desktop created at least 10 days ago locations: \"~/Desktop\" filters: - created: days: 10 actions: - echo: \"Was created at least 10 days ago\" rules: - name: Show all files on your desktop which were created within the last 5 hours locations: \"~/Desktop\" filters: - created: hours: 5 mode: newer actions: - echo: \"Was created within the last 5 hours\" rules: - name: Sort pdfs by year of creation locations: \"~/Documents\" filters: - extension: pdf - created actions: - move: \"~/Documents/PDF/{created.year}/\"","title":"created"},{"location":"03-filters/#duplicate","text":"Finds duplicate files. This filter compares files byte by byte and finds identical files with potentially different filenames. :returns: - {duplicate} -- path to the duplicate source rules: - name: Show all duplicate files in your desktop and download folder (and their subfolders) locations: - ~/Desktop - ~/Downloads sublocations: true filters: - duplicate actions: - echo: \"{path} is a duplicate of {duplicate}\"","title":"duplicate"},{"location":"03-filters/#empty","text":"Finds empty dirs and files rules: - name: \"Recursively delete empty folders\" targets: dirs locations: - path: ~/Desktop max_depth: null filters: - empty actions: - delete","title":"empty"},{"location":"03-filters/#exif","text":"Filter by image EXIF data The exif filter can be used as a filter as well as a way to get exif information into your actions. :returns: {exif} -- a dict of all the collected exif inforamtion available in the file. Typically it consists of the following tags (if present in the file): - ``{exif.image}`` -- information related to the main image - ``{exif.exif}`` -- Exif information - ``{exif.gps}`` -- GPS information - ``{exif.interoperability}`` -- Interoperability information Examples: Show available EXIF data of your pictures: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Pictures subfolders: true filters: - exif actions: - echo: \"{exif}\" Copy all images which contain GPS information while keeping subfolder structure: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Pictures subfolders: true filters: - exif: gps.gpsdate actions: - copy: ~/Pictures/with_gps/{relative_path}/ Filter by camera manufacturer: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Pictures subfolders: true filters: - exif: image.model: Nikon D3200 actions: - move: '~/Pictures/My old Nikon/' Sort images by camera manufacturer. This will create folders for each camera model (for example \"Nikon D3200\", \"iPhone 6s\", \"iPhone 5s\", \"DMC-GX80\") and move the pictures accordingly: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Pictures subfolders: true filters: - extension: jpg - exif: image.model actions: - move: '~/Pictures/{exif.image.model}/'","title":"exif"},{"location":"03-filters/#extension","text":"Filter by file extension :param extensions: The file extensions to match (does not need to start with a colon). :returns: - {extension} -- the original file extension (without colon) - {extension.lower} -- the file extension in lowercase - {extension.upper} -- the file extension in UPPERCASE Examples: Match a single file extension: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - extension: png actions: - echo: 'Found PNG file: {path}' Match multiple file extensions: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - extension: - .jpg - jpeg actions: - echo: 'Found JPG file: {path}' Make all file extensions lowercase: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - extension actions: - rename: '{path.stem}.{extension.lower}' Using extension lists: .. code-block:: yaml :caption: config.yaml img_ext: &img - png - jpg - tiff audio_ext: &audio - mp3 - wav - ogg rules: - folders: '~/Desktop' filters: - extension: - *img - *audio actions: - echo: 'Found media file: {path}'","title":"extension"},{"location":"03-filters/#filecontent","text":"Matches file content with the given regular expression :param str expr: The regular expression to be matched. Any named groups in your regular expression will be returned like this: :returns: - {filecontent.yourgroupname} -- The text matched with the named group (?P<yourgroupname>) Examples: Show the content of all your PDF files: .. code-block::yaml :caption: config.yaml rules: - folders: ~/Documents filters: - extension: pdf - filecontent: '(?P<all>.*)' actions: - echo: \"{filecontent.all}\" Match an invoice with a regular expression and sort by customer: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - filecontent: 'Invoice.*Customer (?P<customer>\\w+)' actions: - move: '~/Documents/Invoices/{filecontent.customer}/'","title":"filecontent"},{"location":"03-filters/#hash","text":"Calculates the hash of a file. Parameters: algorithm ( str ) \u2013 Any hashing algorithm available to python's hashlib . md5 by default. Algorithms guaranteed to be available are shake_256 , sha3_256 , sha1 , sha3_224 , sha384 , sha512 , blake2b , blake2s , sha256 , sha224 , shake_128 , sha3_512 , sha3_384 and md5 . Depending on your python installation and installed libs there may be additional hash algorithms to chose from. To list the available algorithms on your installation run this in a python interpreter: >>> import hashlib >>> hashlib.algorithms_available {'shake_256', 'whirlpool', 'mdc2', 'blake2s', 'sha224', 'shake_128', 'sha3_512', 'sha3_224', 'sha384', 'md5', 'sha1', 'sha512_256', 'blake2b', 'sha256', 'sha512_224', 'ripemd160', 'sha3_384', 'md4', 'sm3', 'sha3_256', 'md5-sha1', 'sha512'} Returns: str \u2013 The hash of the file.","title":"hash"},{"location":"03-filters/#name","text":"Match files by filename :param str match: A matching string in simplematch -syntax (https://github.com/tfeldmann/simplematch) :param str startswith: The filename must begin with the given string :param str contains: The filename must contain the given string :param str endswith: The filename (without extension) must end with the given string :param bool case_sensitive = True: By default, the matching is case sensitive. Change this to False to use case insensitive matching. Examples: Match all files starting with 'Invoice': .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - filename: startswith: Invoice actions: - echo: 'This is an invoice' Match all files starting with 'A' end containing the string 'hole' (case insensitive) .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - filename: startswith: A contains: hole case_sensitive: false actions: - echo: 'Found a match.' Match all files starting with 'A' or 'B' containing '5' or '6' and ending with '_end' .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - filename: startswith: - A - B contains: - 5 - 6 endswith: _end case_sensitive: false actions: - echo: 'Found a match.'","title":"name"},{"location":"03-filters/#size","text":"Matches files and folders by size :param str conditions: Accepts file size conditions, e.g: '>= 500 MB' , '< 20k' , '>0' , '= 10 KiB' . It is possible to define both lower and upper conditions like this: '>20k, < 1 TB' , '>= 20 Mb, <25 Mb' . The filter will match if all given conditions are satisfied. Accepts all units from KB to YB. If no unit is given, kilobytes are assumend. If binary prefix is given (KiB, GiB) the size is calculated using base 1024. :returns: - {size.bytes} -- Size in bytes Examples: Trash big downloads: .. code-block:: yaml :caption: config.yaml rules: - locations: '~/Downloads' targets: files filters: - filesize: '> 0.5 GB' actions: - trash Move all JPEGS bigger > 1MB and <10 MB. Search all subfolders and keep the original relative path. .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Pictures' subfolders: true filters: - extension: - jpg - jpeg - filesize: '>1mb, <10mb' actions: - move: '~/Pictures/sorted/{relative_path}/'","title":"size"},{"location":"03-filters/#lastmodified","text":"Matches files by last modified date :param int years: specify number of years :param int months: specify number of months :param float weeks: specify number of weeks :param float days: specify number of days :param float hours: specify number of hours :param float minutes: specify number of minutes :param float seconds: specify number of seconds :param str mode: either 'older' or 'newer'. 'older' matches all files last modified before the given time, 'newer' matches all files last modified within the given time. (default = 'older') :returns: - {lastmodified.year} -- the year the file was last modified - {lastmodified.month} -- the month the file was last modified - {lastmodified.day} -- the day the file was last modified - {lastmodified.hour} -- the hour the file was last modified - {lastmodified.minute} -- the minute the file was last modified - {lastmodified.second} -- the second the file was last modified Examples: Show all files on your desktop last modified at least 10 days ago: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - lastmodified: days: 10 actions: - echo: 'Was modified at least 10 days ago' Show all files on your desktop which were modified within the last 5 hours: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - lastmodified: hours: 5 mode: newer actions: - echo: 'Was modified within the last 5 hours' Sort pdfs by year of last modification .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Documents' filters: - extension: pdf - lastmodified actions: - move: '~/Documents/PDF/{lastmodified.year}/'","title":"lastmodified"},{"location":"03-filters/#mimetype","text":"Filter by MIME type associated with the file extension. Supports a single string or list of MIME type strings as argument. The types don't need to be fully specified, for example \"audio\" matches everything from \"audio/midi\" to \"audio/quicktime\". You can see a list of known MIME types on your system by running this oneliner: .. code-block:: yaml python3 -c \"import mimetypes as m; print('\\n'.join(sorted(set(m.common_types.values()) | set(m.types_map.values()))))\" Examples rules: - name: \"Show MIME types\" locations: \"~/Downloads\" filters: - mimetype actions: - echo: \"{mimetype}\" rules: - name: \"Filter by 'image' mimetype\" locations: \"~/Downloads\" filters: - mimetype: image actions: - echo: \"This file is an image: {mimetype}\" rules: - name: Filter by specific MIME type locations: \"~/Desktop\" filters: - mimetype: application/pdf actions: - echo: \"Found a PDF file\" rules: - name: Filter by multiple specific MIME types locations: \"~/Music\" filters: - mimetype: - application/pdf - audio/midi actions: - echo: \"Found Midi or PDF.\"","title":"mimetype"},{"location":"03-filters/#python","text":"Use python code to filter files. :param str code: The python code to execute. The code must contain a return statement. :returns: - If your code returns False or None the file is filtered out, otherwise the file is passed on to the next filters. - {python} contains the returned value. If you return a dictionary (for example return {\"some_key\": some_value, \"nested\": {\"k\": 2}} ) it will be accessible via dot syntax in your actions: {python.some_key} , {python.nested.k} . Examples rules: - name: A file name reverser. locations: ~/Documents filters: - extension - python: | return {\"reversed_name\": path.stem[::-1]} actions: - rename: \"{python.reversed_name}.{extension}\" A filter for odd student numbers. Assuming the folder ~/Students contains the files student-01.jpg , student-01.txt , student-02.txt and student-03.txt this rule will print \"Odd student numbers: student-01.txt\" and \"Odd student numbers: student-03.txt\" rules: - name: \"Filter odd student numbers\" locations: ~/Students/ filters: - python: | return int(path.stem.split('-')[1]) % 2 == 1 actions: - echo: \"Odd student numbers: {path.name}\" Advanced usecase. You can access data from previous filters in your python code. This can be used to match files and capturing names with a regular expression and then renaming the files with the output of your python script. rules: - name: \"Access placeholders in python filter\" locations: files filters: - extension: txt - regex: (?P<firstname>\\w+)-(?P<lastname>\\w+)\\..* - python: | emails = { \"Betts\": \"dbetts@mail.de\", \"Cornish\": \"acornish@google.com\", \"Bean\": \"dbean@aol.com\", \"Frey\": \"l-frey@frey.org\", } if regex.lastname in emails: # get emails from wherever return {\"mail\": emails[regex.lastname]} actions: - rename: \"{python.mail}.txt\" Result: Devonte-Betts.txt becomes dbetts@mail.de.txt Alaina-Cornish.txt becomes acornish@google.com.txt Dimitri-Bean.txt becomes dbean@aol.com.txt Lowri-Frey.txt becomes l-frey@frey.org.txt Someunknown-User.txt remains unchanged because the email is not found","title":"python"},{"location":"03-filters/#regex","text":"Matches filenames with the given regular expression :param str expr: The regular expression to be matched. Any named groups in your regular expression will be returned like this: :returns: - {regex.yourgroupname} -- The text matched with the named group (?P<yourgroupname>) Examples: Match an invoice with a regular expression: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - regex: '^RG(\\d{12})-sig\\.pdf$' actions: - move: '~/Documents/Invoices/1und1/' Match and extract data from filenames with regex named groups: This is just like the previous example but we rename the invoice using the invoice number extracted via the regular expression and the named group the_number . .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop filters: - regex: '^RG(?P<the_number>\\d{12})-sig\\.pdf$' actions: - move: ~/Documents/Invoices/1und1/{regex.the_number}.pdf","title":"regex"},{"location":"04-actions/","text":"Actions # This page shows the specifics of each action. For basic action usage and options have a look at the Config section. copy # Copy a file or dir to a new location. If the specified path does not exist it will be created. Parameters: dest ( str ) \u2013 The destination where the file / dir should be copied to. If dest ends with a slash, it is assumed to be a target directory and the file / dir will be copied into dest and keep its name. on_conflict ( str ) \u2013 What should happen in case dest already exists. One of skip , overwrite , trash , rename_new and rename_existing . Defaults to rename_new . rename_template ( str ) \u2013 A template for renaming the file / dir in case of a conflict. Defaults to {name} {counter}{extension} . dest_filesystem ( str ) \u2013 (Optional) A pyfilesystem opener url of the filesystem you want to copy to. If this is not given, the local filesystem is used. The next action will work with the created copy. Examples Copy all pdfs into ~/Desktop/somefolder/ and keep filenames rules: - locations: ~/Desktop filters: - extension: pdf actions: - copy: \"~/Desktop/somefolder/\" Use a placeholder to copy all .pdf files into a \"PDF\" folder and all .jpg files into a \"JPG\" folder. Existing files will be overwritten. rules: - locations: ~/Desktop filters: - extension: - pdf - jpg actions: - copy: dest: \"~/Desktop/{extension.upper}/\" on_conflict: overwrite Copy into the folder Invoices . Keep the filename but do not overwrite existing files. To prevent overwriting files, an index is added to the filename, so somefile.jpg becomes somefile 2.jpg . The counter separator is ' ' by default, but can be changed using the counter_separator property. rules: - locations: ~/Desktop/Invoices filters: - extension: - pdf actions: - copy: dest: \"~/Documents/Invoices/\" on_conflict: \"rename_new\" rename_template: \"{name} {counter}{extension}\" delete # Delete a file from disk. Deleted files have no recovery option! Using the Trash action is strongly advised for most use-cases! Examples rules: - locations: \"~/Downloads\" filters: - lastmodified: days: 365 - extension: - png - jpg actions: - delete rules: - name: Delete all empty subfolders locations: - path: \"~/Downloads\" max_depth: null targets: dirs filters: - empty actions: - delete echo # Prints the given message. This can be useful to test your rules, especially in combination with placeholder variables. Parameters: msg(str) \u2013 The message to print. Accepts placeholder variables. Examples rules: - name: \"Find files older than a year\" locations: ~/Desktop filters: - lastmodified: days: 365 actions: - echo: \"Found old file\" Prints \"Hello World!\" and filepath for each file on the desktop: :caption: config.yaml rules: - locations: - ~/Desktop actions: - echo: \"Hello World! {path}\" This will print something like `Found a PNG: \"test.png\"` for each file on your desktop :caption: config.yaml rules: - locations: - ~/Desktop filters: - Extension actions: - echo: 'Found a {extension.upper}: \"{path.name}\"' Show the `{basedir}` and `{path}` of all files in '~/Downloads', '~/Desktop' and their subfolders: :caption: config.yaml rules: - locations: - ~/Desktop - ~/Downloads subfolders: true actions: - echo: \"Basedir: {basedir}\" - echo: \"Path: {path}\" macos_tags # Add macOS tags. Parameters: *tags ( str ) \u2013 A list of tags or a single tag. The color can be specified in brackets after the tag name, for example: macos_tags: \"Invoices (red)\" Available colors are none , gray , green , purple , blue , yellow , red and orange . Examples rules: - name: \"add a single tag\" locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: Invoice Adding multiple tags (\"Invoice\" and \"Important\") rules: - locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: - Important - Invoice Specify tag colors rules: - locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: - Important (green) - Invoice (purple) Add a templated tag with color rules: - locations: \"~/Documents/Invoices\" filters: - created actions: - macos_tags: - Year-{created.year} (red) move # Move a file to a new location. The file can also be renamed. If the specified path does not exist it will be created. If you only want to rename the file and keep the folder, it is easier to use the Rename-Action. :param str dest: The destination folder or path. If dest ends with a slash / backslash, the file will be moved into this folder and not renamed. :param bool overwrite: specifies whether existing files should be overwritten. Otherwise it will start enumerating files (append a counter to the filename) to resolve naming conflicts. [Default: False] :param str counter_separator: specifies the separator between filename and the appended counter. Only relevant if overwrite is disabled. [Default: ' ' ] Examples: Move all pdfs and jpgs from the desktop into the folder \"~/Desktop/media/\". Filenames are not changed. .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop filters: - extension: - pdf - jpg actions: - move: '~/Desktop/media/' Use a placeholder to move all .pdf files into a \"PDF\" folder and all .jpg files into a \"JPG\" folder. Existing files will be overwritten. .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop filters: - extension: - pdf - jpg actions: - move: dest: '~/Desktop/{extension.upper}/' overwrite: true Move pdfs into the folder Invoices . Keep the filename but do not overwrite existing files. To prevent overwriting files, an index is added to the filename, so somefile.jpg becomes somefile 2.jpg . .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop/Invoices filters: - extension: - pdf actions: - move: dest: '~/Documents/Invoices/' overwrite: false counter_separator: '_' python # Execute python code in your config file. :param str code: The python code to execute Examples: A basic example that shows how to get the current file path and do some printing in a for loop. The | is yaml syntax for defining a string literal spanning multiple lines. .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' actions: - python: | print('The path of the current file is %s' % path) for _ in range(5): print('Heyho, its me from the loop') You can access filter data: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop filters: - regex: '^(?P<name>.*)\\.(?P<extension>.*)$' actions: - python: | print('Name: %s' % regex.name) print('Extension: %s' % regex.extension) You have access to all the python magic -- do a google search for each filename starting with an underscore: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop filters: - filename: startswith: '_' actions: - python: | import webbrowser webbrowser.open('https://www.google.com/search?q=%s' % path.stem) rename # Renames a file. :param str name: The new filename. Can be a format string which uses file attributes from a filter. :param bool overwrite: specifies whether existing files should be overwritten. Otherwise it will start enumerating files (append a counter to the filename) to resolve naming conflicts. [Default: False] :param str counter_separator: specifies the separator between filename and the appended counter. Only relevant if overwrite is disabled. [Default: ' ' ] Examples: Convert all .PDF file extensions to lowercase (.pdf): .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - extension: PDF actions: - rename: \"{path.stem}.pdf\" Convert all file extensions to lowercase: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - Extension actions: - rename: \"{path.stem}.{extension.lower}\" shell # Executes a shell command :param str cmd: The command to execute. Examples: (macOS) Open all pdfs on your desktop: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - extension: pdf actions: - shell: 'open \"{path}\"' symlink # Create a symbolic link. Parameters: dest ( str ) \u2013 The symlink destination. If dest ends with a slash `/``, create the symlink in the given directory. Can contain placeholders. Only the local filesystem is supported. trash # Move a file or dir into the trash. Example: rules: - name: Move all JPGs and PNGs on the desktop which are older than one year into the trash locations: \"~/Desktop\" filters: - lastmodified: years: 1 mode: older - extension: - png - jpg actions: - trash","title":"Actions"},{"location":"04-actions/#actions","text":"This page shows the specifics of each action. For basic action usage and options have a look at the Config section.","title":"Actions"},{"location":"04-actions/#copy","text":"Copy a file or dir to a new location. If the specified path does not exist it will be created. Parameters: dest ( str ) \u2013 The destination where the file / dir should be copied to. If dest ends with a slash, it is assumed to be a target directory and the file / dir will be copied into dest and keep its name. on_conflict ( str ) \u2013 What should happen in case dest already exists. One of skip , overwrite , trash , rename_new and rename_existing . Defaults to rename_new . rename_template ( str ) \u2013 A template for renaming the file / dir in case of a conflict. Defaults to {name} {counter}{extension} . dest_filesystem ( str ) \u2013 (Optional) A pyfilesystem opener url of the filesystem you want to copy to. If this is not given, the local filesystem is used. The next action will work with the created copy. Examples Copy all pdfs into ~/Desktop/somefolder/ and keep filenames rules: - locations: ~/Desktop filters: - extension: pdf actions: - copy: \"~/Desktop/somefolder/\" Use a placeholder to copy all .pdf files into a \"PDF\" folder and all .jpg files into a \"JPG\" folder. Existing files will be overwritten. rules: - locations: ~/Desktop filters: - extension: - pdf - jpg actions: - copy: dest: \"~/Desktop/{extension.upper}/\" on_conflict: overwrite Copy into the folder Invoices . Keep the filename but do not overwrite existing files. To prevent overwriting files, an index is added to the filename, so somefile.jpg becomes somefile 2.jpg . The counter separator is ' ' by default, but can be changed using the counter_separator property. rules: - locations: ~/Desktop/Invoices filters: - extension: - pdf actions: - copy: dest: \"~/Documents/Invoices/\" on_conflict: \"rename_new\" rename_template: \"{name} {counter}{extension}\"","title":"copy"},{"location":"04-actions/#delete","text":"Delete a file from disk. Deleted files have no recovery option! Using the Trash action is strongly advised for most use-cases! Examples rules: - locations: \"~/Downloads\" filters: - lastmodified: days: 365 - extension: - png - jpg actions: - delete rules: - name: Delete all empty subfolders locations: - path: \"~/Downloads\" max_depth: null targets: dirs filters: - empty actions: - delete","title":"delete"},{"location":"04-actions/#echo","text":"Prints the given message. This can be useful to test your rules, especially in combination with placeholder variables. Parameters: msg(str) \u2013 The message to print. Accepts placeholder variables. Examples rules: - name: \"Find files older than a year\" locations: ~/Desktop filters: - lastmodified: days: 365 actions: - echo: \"Found old file\" Prints \"Hello World!\" and filepath for each file on the desktop: :caption: config.yaml rules: - locations: - ~/Desktop actions: - echo: \"Hello World! {path}\" This will print something like `Found a PNG: \"test.png\"` for each file on your desktop :caption: config.yaml rules: - locations: - ~/Desktop filters: - Extension actions: - echo: 'Found a {extension.upper}: \"{path.name}\"' Show the `{basedir}` and `{path}` of all files in '~/Downloads', '~/Desktop' and their subfolders: :caption: config.yaml rules: - locations: - ~/Desktop - ~/Downloads subfolders: true actions: - echo: \"Basedir: {basedir}\" - echo: \"Path: {path}\"","title":"echo"},{"location":"04-actions/#macos_tags","text":"Add macOS tags. Parameters: *tags ( str ) \u2013 A list of tags or a single tag. The color can be specified in brackets after the tag name, for example: macos_tags: \"Invoices (red)\" Available colors are none , gray , green , purple , blue , yellow , red and orange . Examples rules: - name: \"add a single tag\" locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: Invoice Adding multiple tags (\"Invoice\" and \"Important\") rules: - locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: - Important - Invoice Specify tag colors rules: - locations: \"~/Documents/Invoices\" filters: - name: startswith: \"Invoice\" - extension: pdf actions: - macos_tags: - Important (green) - Invoice (purple) Add a templated tag with color rules: - locations: \"~/Documents/Invoices\" filters: - created actions: - macos_tags: - Year-{created.year} (red)","title":"macos_tags"},{"location":"04-actions/#move","text":"Move a file to a new location. The file can also be renamed. If the specified path does not exist it will be created. If you only want to rename the file and keep the folder, it is easier to use the Rename-Action. :param str dest: The destination folder or path. If dest ends with a slash / backslash, the file will be moved into this folder and not renamed. :param bool overwrite: specifies whether existing files should be overwritten. Otherwise it will start enumerating files (append a counter to the filename) to resolve naming conflicts. [Default: False] :param str counter_separator: specifies the separator between filename and the appended counter. Only relevant if overwrite is disabled. [Default: ' ' ] Examples: Move all pdfs and jpgs from the desktop into the folder \"~/Desktop/media/\". Filenames are not changed. .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop filters: - extension: - pdf - jpg actions: - move: '~/Desktop/media/' Use a placeholder to move all .pdf files into a \"PDF\" folder and all .jpg files into a \"JPG\" folder. Existing files will be overwritten. .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop filters: - extension: - pdf - jpg actions: - move: dest: '~/Desktop/{extension.upper}/' overwrite: true Move pdfs into the folder Invoices . Keep the filename but do not overwrite existing files. To prevent overwriting files, an index is added to the filename, so somefile.jpg becomes somefile 2.jpg . .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop/Invoices filters: - extension: - pdf actions: - move: dest: '~/Documents/Invoices/' overwrite: false counter_separator: '_'","title":"move"},{"location":"04-actions/#python","text":"Execute python code in your config file. :param str code: The python code to execute Examples: A basic example that shows how to get the current file path and do some printing in a for loop. The | is yaml syntax for defining a string literal spanning multiple lines. .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' actions: - python: | print('The path of the current file is %s' % path) for _ in range(5): print('Heyho, its me from the loop') You can access filter data: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop filters: - regex: '^(?P<name>.*)\\.(?P<extension>.*)$' actions: - python: | print('Name: %s' % regex.name) print('Extension: %s' % regex.extension) You have access to all the python magic -- do a google search for each filename starting with an underscore: .. code-block:: yaml :caption: config.yaml rules: - folders: ~/Desktop filters: - filename: startswith: '_' actions: - python: | import webbrowser webbrowser.open('https://www.google.com/search?q=%s' % path.stem)","title":"python"},{"location":"04-actions/#rename","text":"Renames a file. :param str name: The new filename. Can be a format string which uses file attributes from a filter. :param bool overwrite: specifies whether existing files should be overwritten. Otherwise it will start enumerating files (append a counter to the filename) to resolve naming conflicts. [Default: False] :param str counter_separator: specifies the separator between filename and the appended counter. Only relevant if overwrite is disabled. [Default: ' ' ] Examples: Convert all .PDF file extensions to lowercase (.pdf): .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - extension: PDF actions: - rename: \"{path.stem}.pdf\" Convert all file extensions to lowercase: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - Extension actions: - rename: \"{path.stem}.{extension.lower}\"","title":"rename"},{"location":"04-actions/#shell","text":"Executes a shell command :param str cmd: The command to execute. Examples: (macOS) Open all pdfs on your desktop: .. code-block:: yaml :caption: config.yaml rules: - folders: '~/Desktop' filters: - extension: pdf actions: - shell: 'open \"{path}\"'","title":"shell"},{"location":"04-actions/#symlink","text":"Create a symbolic link. Parameters: dest ( str ) \u2013 The symlink destination. If dest ends with a slash `/``, create the symlink in the given directory. Can contain placeholders. Only the local filesystem is supported.","title":"symlink"},{"location":"04-actions/#trash","text":"Move a file or dir into the trash. Example: rules: - name: Move all JPGs and PNGs on the desktop which are older than one year into the trash locations: \"~/Desktop\" filters: - lastmodified: years: 1 mode: older - extension: - png - jpg actions: - trash","title":"trash"},{"location":"05-changelog/","text":"Changelog # v2 - In Progress # This is a huge update with a large refactoring. Please backup all your important stuff before running. what's new # Completely rewritten core! Respects your rule order - safer, less magic, less surprises. (v1 tried to be clever. v2 now works your config file from top to bottom) Now you can organize (S)FTP, S3 Buckets, Zip archives and many more. Most of the actions like move and copy even work across file systems! Available filesystems You can now target folders with your rules. Like copying a whole folder, renaming etc. max_depth setting when recursing into subfolders starts instantly (does not need to gather all the files before starting) filters can now be excluded nice terminal output rule names cleaner config file validation and stricter format option to run python actions in simulation added empty filter. new conflict resolution settings in move , copy and rename action: skip , overwrite , trash , rename_new , rename_existing as well as a rename_template parameter. the shell action now returns stdout and errorcode. Added symlink action changed # The config file format got a long due overhaul. Please see the migration documentation for what is new. The timezone keyword for lastmodified and created was removed. The timezone is now the local timezone by default. The filesize filter was renamed to size and can now be used to get directory sizes as well. The filename filter was renamed to name and can now be used to get directory names as well. removed # Glob syntax is gone from folders (no longer needed) \"!\"-exclude syntax is gone (no longer needed) v1.10.1 (2021-04-21) # Action macos_tags now supports colors and placeholders. Show full expanded path if folder is not found. v1.10.0 (2021-04-20) # Add filter mimetype Add action macos_tags Support simplematch syntax in lename -filter. Updated dependencies Because installing textract is quite hard on some platforms it is now an optional dendency. Install it with pip install organize-tool[textract] This version needs python 3.6 minimum. Some dependencies that were simply backports (thlib2, typing) are removed. Add timezones in created and last_modified filters (Thank you, @win0err!) v1.9.1 (2020-11-10) # Add {env} variable Add {now} variable v1.9 (2020-06-12) # Add filter Duplicate . v1.8.2 (2020-04-03) # Fix a bug in the filename filter config parsing algorithm with digits-only filenames. v1.8.1 (2020-03-28) # Flatten filter and action lists to allow enhanced config file configuration (Thanks to @rawdamedia!) Add support for multiline content filters (Thanks to @zor-el!) v1.8.0 (2020-03-04) # Added action Delete . Added filter FileContent . Python 3.4 is officially deprecated and no longer supported. --config-file command line option now supports ~ for user folder and expansion oenvironment variables Added years , months , weeks and seconds parameter to filter created and stmodified v1.7.0 (2019-11-26) # Added filter Exif to filter by image exif data. Placeholder variable properties are now case insensitve. v1.6.2 (2019-11-22) # Fix Rename action ( 'PosixPath' object has no attribute 'items' ). Use type hints everywhere. v1.6.1 (2019-10-25) # Shows a warning for missing folders instead of raising an exception. v1.6 (2019-08-19) # Added filter: Python Added filter: FileSize The organize module can now be run directly: python3 -m organize Various code simplifications and speedups. Fixes an issue with globstring file exclusion. Remove clint dependency as it is no longer maintained. Added various integration tests The \"~~ SIMULATION ~~\"-banner now takes up the whole terminal width v1.5.3 (2019-08-01) # Filename filter now supports lists. v1.5.2 (2019-07-29) # Environment variables in folder pathes are now expanded (syntax $name or ${name} a additionally %name% on windows). F example this allows the usage of e.g. %public/Desktop% in windows. v1.5.1 (2019-07-23) # New filter \"Created\" to filter by creation date. Fixes issue #39 where globstrings don't work most of the time. Integration test for issue #39 Support indented config files v1.5 (2019-07-17) # Fixes issue #31 where the {path} variable always resolves to the source path Updated dependencies Exclude changelog and readme from published wheel v1.4.5 (2019-07-03) # Filter and Actions names are now case-insensitive v1.4.4 (2019-07-02) # Fixes issues #36 with umlauts in config file on windows v1.4.3 (2019-06-05) # Use safe YAML loader to fix a deprecation warning. (Thanks mope1!) Better error message if a folder does not exist. (Again thanks mope1!) Fix example code in documentation for LastModified filter. Custom config file locations (given by cmd line argument or environment variable). config --debug now shows the full path to the config file. v1.4.2 (2018-11-14) # Fixes a bug with command line arguments in the $EDITOR environment viable. Fixes a bug where an empty config wouldn't show the correct error message. Fix binary wheel creation in setup.py by using environment markers v1.4.1 (2018-10-05) # A custom separator counter_separator can now be set in the actions Move, Cy and Rename. v1.4 (2018-09-21) # Fixes a bug where glob wildcards are not detected correctly Adds support for excluding folders and files via glob syntax. Makes sure that files are only handled once per rule. v1.3 (2018-07-06) # Glob support in folder configuration. New variable {relative_path} is now available in actions. v1.2 (2018-03-19) # Shows the relative path to files in subfolders. v1.1 (2018-03-13) # Removes the colon from extension filter output so {extension.lower} now rurns 'png' instead of '.png' . v1.0 (2018-03-13) # Initial release.","title":"Changelog"},{"location":"05-changelog/#changelog","text":"","title":"Changelog"},{"location":"05-changelog/#v2-in-progress","text":"This is a huge update with a large refactoring. Please backup all your important stuff before running.","title":"v2 - In Progress"},{"location":"05-changelog/#whats-new","text":"Completely rewritten core! Respects your rule order - safer, less magic, less surprises. (v1 tried to be clever. v2 now works your config file from top to bottom) Now you can organize (S)FTP, S3 Buckets, Zip archives and many more. Most of the actions like move and copy even work across file systems! Available filesystems You can now target folders with your rules. Like copying a whole folder, renaming etc. max_depth setting when recursing into subfolders starts instantly (does not need to gather all the files before starting) filters can now be excluded nice terminal output rule names cleaner config file validation and stricter format option to run python actions in simulation added empty filter. new conflict resolution settings in move , copy and rename action: skip , overwrite , trash , rename_new , rename_existing as well as a rename_template parameter. the shell action now returns stdout and errorcode. Added symlink action","title":"what's new"},{"location":"05-changelog/#changed","text":"The config file format got a long due overhaul. Please see the migration documentation for what is new. The timezone keyword for lastmodified and created was removed. The timezone is now the local timezone by default. The filesize filter was renamed to size and can now be used to get directory sizes as well. The filename filter was renamed to name and can now be used to get directory names as well.","title":"changed"},{"location":"05-changelog/#removed","text":"Glob syntax is gone from folders (no longer needed) \"!\"-exclude syntax is gone (no longer needed)","title":"removed"},{"location":"05-changelog/#v1101-2021-04-21","text":"Action macos_tags now supports colors and placeholders. Show full expanded path if folder is not found.","title":"v1.10.1 (2021-04-21)"},{"location":"05-changelog/#v1100-2021-04-20","text":"Add filter mimetype Add action macos_tags Support simplematch syntax in lename -filter. Updated dependencies Because installing textract is quite hard on some platforms it is now an optional dendency. Install it with pip install organize-tool[textract] This version needs python 3.6 minimum. Some dependencies that were simply backports (thlib2, typing) are removed. Add timezones in created and last_modified filters (Thank you, @win0err!)","title":"v1.10.0 (2021-04-20)"},{"location":"05-changelog/#v191-2020-11-10","text":"Add {env} variable Add {now} variable","title":"v1.9.1 (2020-11-10)"},{"location":"05-changelog/#v19-2020-06-12","text":"Add filter Duplicate .","title":"v1.9 (2020-06-12)"},{"location":"05-changelog/#v182-2020-04-03","text":"Fix a bug in the filename filter config parsing algorithm with digits-only filenames.","title":"v1.8.2 (2020-04-03)"},{"location":"05-changelog/#v181-2020-03-28","text":"Flatten filter and action lists to allow enhanced config file configuration (Thanks to @rawdamedia!) Add support for multiline content filters (Thanks to @zor-el!)","title":"v1.8.1 (2020-03-28)"},{"location":"05-changelog/#v180-2020-03-04","text":"Added action Delete . Added filter FileContent . Python 3.4 is officially deprecated and no longer supported. --config-file command line option now supports ~ for user folder and expansion oenvironment variables Added years , months , weeks and seconds parameter to filter created and stmodified","title":"v1.8.0 (2020-03-04)"},{"location":"05-changelog/#v170-2019-11-26","text":"Added filter Exif to filter by image exif data. Placeholder variable properties are now case insensitve.","title":"v1.7.0 (2019-11-26)"},{"location":"05-changelog/#v162-2019-11-22","text":"Fix Rename action ( 'PosixPath' object has no attribute 'items' ). Use type hints everywhere.","title":"v1.6.2 (2019-11-22)"},{"location":"05-changelog/#v161-2019-10-25","text":"Shows a warning for missing folders instead of raising an exception.","title":"v1.6.1 (2019-10-25)"},{"location":"05-changelog/#v16-2019-08-19","text":"Added filter: Python Added filter: FileSize The organize module can now be run directly: python3 -m organize Various code simplifications and speedups. Fixes an issue with globstring file exclusion. Remove clint dependency as it is no longer maintained. Added various integration tests The \"~~ SIMULATION ~~\"-banner now takes up the whole terminal width","title":"v1.6 (2019-08-19)"},{"location":"05-changelog/#v153-2019-08-01","text":"Filename filter now supports lists.","title":"v1.5.3 (2019-08-01)"},{"location":"05-changelog/#v152-2019-07-29","text":"Environment variables in folder pathes are now expanded (syntax $name or ${name} a additionally %name% on windows). F example this allows the usage of e.g. %public/Desktop% in windows.","title":"v1.5.2 (2019-07-29)"},{"location":"05-changelog/#v151-2019-07-23","text":"New filter \"Created\" to filter by creation date. Fixes issue #39 where globstrings don't work most of the time. Integration test for issue #39 Support indented config files","title":"v1.5.1 (2019-07-23)"},{"location":"05-changelog/#v15-2019-07-17","text":"Fixes issue #31 where the {path} variable always resolves to the source path Updated dependencies Exclude changelog and readme from published wheel","title":"v1.5 (2019-07-17)"},{"location":"05-changelog/#v145-2019-07-03","text":"Filter and Actions names are now case-insensitive","title":"v1.4.5 (2019-07-03)"},{"location":"05-changelog/#v144-2019-07-02","text":"Fixes issues #36 with umlauts in config file on windows","title":"v1.4.4 (2019-07-02)"},{"location":"05-changelog/#v143-2019-06-05","text":"Use safe YAML loader to fix a deprecation warning. (Thanks mope1!) Better error message if a folder does not exist. (Again thanks mope1!) Fix example code in documentation for LastModified filter. Custom config file locations (given by cmd line argument or environment variable). config --debug now shows the full path to the config file.","title":"v1.4.3 (2019-06-05)"},{"location":"05-changelog/#v142-2018-11-14","text":"Fixes a bug with command line arguments in the $EDITOR environment viable. Fixes a bug where an empty config wouldn't show the correct error message. Fix binary wheel creation in setup.py by using environment markers","title":"v1.4.2 (2018-11-14)"},{"location":"05-changelog/#v141-2018-10-05","text":"A custom separator counter_separator can now be set in the actions Move, Cy and Rename.","title":"v1.4.1 (2018-10-05)"},{"location":"05-changelog/#v14-2018-09-21","text":"Fixes a bug where glob wildcards are not detected correctly Adds support for excluding folders and files via glob syntax. Makes sure that files are only handled once per rule.","title":"v1.4 (2018-09-21)"},{"location":"05-changelog/#v13-2018-07-06","text":"Glob support in folder configuration. New variable {relative_path} is now available in actions.","title":"v1.3 (2018-07-06)"},{"location":"05-changelog/#v12-2018-03-19","text":"Shows the relative path to files in subfolders.","title":"v1.2 (2018-03-19)"},{"location":"05-changelog/#v11-2018-03-13","text":"Removes the colon from extension filter output so {extension.lower} now rurns 'png' instead of '.png' .","title":"v1.1 (2018-03-13)"},{"location":"05-changelog/#v10-2018-03-13","text":"Initial release.","title":"v1.0 (2018-03-13)"},{"location":"06-updating-from-v1/","text":"Updating from organize v1.x # First of all, thank you for being a long time user of organize . As this project is only maintained by the single person writing this article it is not feasible to write an automatic config file migration or a compatibility layer. Many people use organize for important documents and personal files, this is not something I want to half-ass. So if you want all the new goodies, you'll need to do some changes in your config. Otherwise feel free to pin organize to the latest v1.x. Config # folders must be renamed to locations . New options: Locations . the glob syntax (eg. \"~/Documents/**\" ) has been removed. the exclamation mark exclude (eg. \"! ~/Desktop\" ) syntax has been removed. They are replaced by the max_depth , exclude_files , exclude_dirs , filter and filter_dirs settings. See Locations . the subfolders setting is removed and replaced by the max_depth setting of a specific location. You can now name your rules via name . The enabled setting has been removed. # TODO: ? organize v1.x: rules: # find some pdf files in various dirs and echo \"Hello\" for each one - folders: - \"~/Desktop/**/*.pdf\" - \"! ~/Desktop/donotmove/*\" subfolders: true ... # move all pdfs into documents - folders: - \"~/Downloads/*.pdf\" ... becomes (organize v2.x) rules: - name: find some pdf files in various dirs and echo \"Hello\" for each one locations: - path: ~/Desktop/ max_depth: null filter: \"*.pdf\" exclude_dirs: donotmove ... - name: move all pdfs into documents locations: \"~/Downloads\" filters: - extension: pdf ... Filters # created no longer accepts a timezone and uses the local timezone by default. lastmodified no longer accepts a timezone and uses the local timezone by default. filename is renamed to name . filesize is renamed to size . Actions # copy arguments changed.","title":"Updating from organize v1.x"},{"location":"06-updating-from-v1/#updating-from-organize-v1x","text":"First of all, thank you for being a long time user of organize . As this project is only maintained by the single person writing this article it is not feasible to write an automatic config file migration or a compatibility layer. Many people use organize for important documents and personal files, this is not something I want to half-ass. So if you want all the new goodies, you'll need to do some changes in your config. Otherwise feel free to pin organize to the latest v1.x.","title":"Updating from organize v1.x"},{"location":"06-updating-from-v1/#config","text":"folders must be renamed to locations . New options: Locations . the glob syntax (eg. \"~/Documents/**\" ) has been removed. the exclamation mark exclude (eg. \"! ~/Desktop\" ) syntax has been removed. They are replaced by the max_depth , exclude_files , exclude_dirs , filter and filter_dirs settings. See Locations . the subfolders setting is removed and replaced by the max_depth setting of a specific location. You can now name your rules via name . The enabled setting has been removed. # TODO: ? organize v1.x: rules: # find some pdf files in various dirs and echo \"Hello\" for each one - folders: - \"~/Desktop/**/*.pdf\" - \"! ~/Desktop/donotmove/*\" subfolders: true ... # move all pdfs into documents - folders: - \"~/Downloads/*.pdf\" ... becomes (organize v2.x) rules: - name: find some pdf files in various dirs and echo \"Hello\" for each one locations: - path: ~/Desktop/ max_depth: null filter: \"*.pdf\" exclude_dirs: donotmove ... - name: move all pdfs into documents locations: \"~/Downloads\" filters: - extension: pdf ...","title":"Config"},{"location":"06-updating-from-v1/#filters","text":"created no longer accepts a timezone and uses the local timezone by default. lastmodified no longer accepts a timezone and uses the local timezone by default. filename is renamed to name . filesize is renamed to size .","title":"Filters"},{"location":"06-updating-from-v1/#actions","text":"copy arguments changed.","title":"Actions"}]}